---
- name: Get the supported resource modules
  ansible.netcommon.network_resource:
    os_name: "{{ ansible_network_os }}"
  register: persist_network_resources_list

- name: Set default resources
  ansible.builtin.set_fact:
    persist_resources: "{{ persist_network_resources_list['modules'] }}"
  when: persist_resources is undefined

- name: Set network resources when resources is not defined
  ansible.builtin.set_fact:
    persist_network_resources:
      actionable: "{{ persist_resources }}"
      unsupported: []
  when: resources is undefined


- name: Set Network resources
  ansible.builtin.set_fact:
    persist_network_resources: "{{ persist_network_resources_list['modules'] | ansible.utils.param_list_compare(resources) }}"
  when: resources is defined
  
- name: Resolve inventory
  ansible.builtin.include_tasks: manage_inventory.yaml

- name: Include retrieve tasks
  ansible.builtin.include_tasks: retrieve.yaml
  when: data_store['scm'] is defined

- name: Ensure persist_result is initialized as an empty list
  ansible.builtin.set_fact:
    persist_result: {}

- name: Include facts tasks
  ansible.builtin.include_tasks: facts.yaml
  loop: "{{ persist_network_resources['actionable'] }}"
  loop_control:
    loop_var: res

- name: Include System resources
  ansible.builtin.include_tasks: system_resources.yaml

- name: Add gathered system data structure under 'device_info' key
  ansible.builtin.set_fact:
    persist_result:
      all_gathered_resources: >-
        {{
          (persist_result | default({}))
          | combine(
              {'device_info': (gathered_system_data | default({})) | combine({'ansible_network_os': ansible_network_os | default('')})}
            )
        }}

- name: Store persist_result as pretty JSON
  ansible.builtin.set_fact:
    persist_result_output: "{{ persist_result | to_nice_json }}"
  when: format is defined and format == 'json'
 
- name: Store persist_result as pretty JSON
  ansible.builtin.set_fact:
    persist_result_output: "{{ persist_result | to_nice_yaml }}"
  when: format is defined and format == 'yaml' or format is not defined

- name: Ensure dicttoxml is installed on the control node for XML output
  ansible.builtin.pip:
    name: dicttoxml
    state: present
  delegate_to: localhost
  when: format is defined and format == 'xml'

- name: Convert gathered facts to pretty XML format
  become: false
  ansible.builtin.command:
    cmd: >
      python -c "import sys, json, dicttoxml; from xml.dom import minidom;
      xml_bytes = dicttoxml.dicttoxml(json.load(sys.stdin), custom_root='facts');
      dom = minidom.parseString(xml_bytes);
      pretty_xml = dom.toprettyxml(indent='  ');
      print(pretty_xml)"
  
  args:
    stdin: "{{ persist_result | to_json }}" 
  register: xml_conversion_output
  changed_when: false
  check_mode: no       
  when: format is defined and format == 'xml'

- name: Display gathered facts as pretty XML
  ansible.builtin.set_fact:
    persist_result_output: "{{ xml_conversion_output.stdout }}"
  when:
    - format is defined
    - format == 'xml'
    - xml_conversion_output is defined
    - not xml_conversion_output.failed

- name: Ensure pandas and pyarrow are installed on the control node for CSV output
  ansible.builtin.pip:
    name: 
      - pandas
      - pyarrow
    state: present
  delegate_to: localhost
  run_once: true
  become: false
  when: format is defined and format == 'csv'

- name: Set CSV output filename
  ansible.builtin.set_fact:
    csv_output_filename: "{{ output_file | default('network_inventory.csv') }}"
  when: format is defined and format == 'csv'
  run_once: true

- name: Create CSV converter script
  ansible.builtin.copy:
    dest: "{{ playbook_dir }}/csv_converter_temp.py"
    mode: '0755'
    content: |
      #!/usr/bin/env python3
      import sys
      import json
      import pandas as pd
      import os
      import datetime

      def flatten_dict(d, parent_key="", sep="_"):
          items = []
          for k, v in d.items():
              new_key = f"{parent_key}{sep}{k}" if parent_key else k
              if isinstance(v, dict):
                  items.extend(flatten_dict(v, new_key, sep=sep).items())
              elif isinstance(v, list):
                  for i, item in enumerate(v):
                      if isinstance(item, dict):
                          items.extend(flatten_dict(item, f"{new_key}{sep}{i}", sep=sep).items())
                      else:
                          items.append((f"{new_key}{sep}{i}", str(item)))
              else:
                  items.append((new_key, v))
          return dict(items)

      try:
          data = json.load(sys.stdin)
          flattened_data = flatten_dict(data)
          df = pd.DataFrame([flattened_data])
          
          # Add timestamp and metadata
          timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
          
          # Print CSV data to stdout for Ansible to capture
          print(df.to_csv(index=False))
          
      except Exception as e:
          sys.stderr.write(f"Error: {str(e)}\n")
          sys.exit(1)
  delegate_to: localhost
  when: format is defined and format == 'csv'
  register: csv_script_result
  changed_when: false

- name: Convert gathered facts to CSV format
  ansible.builtin.command:
    cmd: "python3 {{ playbook_dir }}/csv_converter_temp.py"
  args:
    stdin: "{{ persist_result | to_json }}"
  register: csv_conversion_output
  changed_when: false
  check_mode: no
  delegate_to: localhost
  when: format is defined and format == 'csv'

- name: Display gathered facts as CSV
  ansible.builtin.debug:
    msg: "{{ csv_conversion_output.stdout }}"
  when:
    - format is defined
    - format == 'csv'
    - csv_conversion_output is defined
    - not csv_conversion_output.failed

- name: Set persist_result_output from CSV stdout
  ansible.builtin.set_fact:
    persist_result_output: "{{ csv_conversion_output.stdout }}"
  when:
    - format is defined
    - format == 'csv'
    - csv_conversion_output is defined
    - not csv_conversion_output.failed
  
  
- name: write to file
  ansible.builtin.include_tasks: write_to_file.yaml

- name: Include publish with tag tasks
  ansible.builtin.include_tasks: publish_tag.yaml
  when:
    - data_store.scm.origin is defined
    - data_store.scm.origin.tag is defined

- name: Include publish without tag tasks
  ansible.builtin.include_tasks: publish.yaml
  when:
    - data_store.scm.origin is defined
    - data_store.scm.origin.tag is not defined
